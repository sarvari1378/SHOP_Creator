name: 2. Process Item Request Queue

on:
  issues:
    types: [labeled]

jobs:
  process_request:
    # شرط اجرا: فقط برای Issue هایی اجرا شو که هم لیبل درست دارند و هم عنوان مشخص
    if: |
      github.event.label.name == 'new-item-request' &&
      startsWith(github.event.issue.title, 'New Item Request:')
    
    runs-on: ubuntu-latest

    # این بخش، مشکل اصلی شما (Race Condition) را حل می‌کند
    concurrency:
      group: json-update-processor # یک نام گروه ثابت برای ایجاد صف
      cancel-in-progress: false   # اجراهای جدید منتظر می‌مانند، قبلی‌ها لغو نمی‌شوند

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Parse data from issue body
        id: parse_issue
        run: |
          ISSUE_BODY="${{ github.event.issue.body }}"
          
          # استخراج اطلاعات از متن Issue با استفاده از grep و sed
          TITLE=$(echo "$ISSUE_BODY" | grep -oP '(?<=^\*\*Title:\*\* `).*(?=`)')
          DESC_EN=$(echo "$ISSUE_BODY" | grep -oP '(?<=^\*\*English Description:\*\* `).*(?=`)')
          DESC_FA=$(echo "$ISSUE_BODY" | grep -oP '(?<=^\*\*Persian Description:\*\* `).*(?=`)')
          IMAGE_NAME=$(echo "$ISSUE_BODY" | grep -oP '(?<=^\*\*Image Filename:\*\* `).*(?=`)')

          # تنظیم خروجی‌ها برای استفاده در مراحل بعدی
          echo "title=${TITLE}" >> $GITHUB_OUTPUT
          echo "english_description=${DESC_EN}" >> $GITHUB_OUTPUT
          echo "persian_description=${DESC_FA}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Update data.json file
        run: |
          IMAGE_NAME="${{ steps.parse_issue.outputs.image_name }}"
          IMAGE_RAW_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/Images/${IMAGE_NAME}"

          ITEM_TITLE="${{ steps.parse_issue.outputs.title }}"

          # همان تابع قبلی شما برای فرمت کردن توضیحات
          add_newline_before_words() {
            local input="$1"
            local words_to_add_newline=("Ring" "Silver" "Weight" "Type" "مديل" "نوع" "عيار" "الوزن")
            for word in "${words_to_add_newline[@]}"; do
              input=$(echo "$input" | sed "s/\b$word\b/\n$word/g")
            done
            echo "$input"
          }

          ITEM_DESC_EN=$(add_newline_before_words "${{ steps.parse_issue.outputs.english_description }}")
          ITEM_DESC_FA=$(add_newline_before_words "${{ steps.parse_issue.outputs.persian_description }}")

          DATA_FILE="Data.json"
          json_content=$(cat $DATA_FILE)

          new_item=$(
            jq -n --arg title "$ITEM_TITLE" \
                  --arg englishDescription "$ITEM_DESC_EN" \
                  --arg persianDescription "$ITEM_DESC_FA" \
                  --arg image "$IMAGE_RAW_URL" \
                  '{title: $title, englishDescription: $englishDescription, persianDescription: $persianDescription, image: $image}'
          )

          new_json=$(echo "$json_content" | jq ".items += [$new_item]")
          echo "$new_json" | jq '.' > $DATA_FILE
          echo "File updated successfully in memory."
      
      - name: Commit and push changes
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # چون کارها سریالی هستند، احتمال تداخل بسیار کم است، اما pull همچنان کار خوبی است
          git pull origin main

          git add Data.json
          git commit -m "Add item from Issue #${{ github.event.issue.number }}: ${{ steps.parse_issue.outputs.title }}"
          git push

      - name: Close the issue as completed
        uses: peter-evans/close-issue@v3
        with:
          issue-number: ${{ github.event.issue.number }}
          comment: "✅ This request has been successfully processed and the item has been added. See commit for details."
          token: ${{ secrets.GITHUB_TOKEN }}
